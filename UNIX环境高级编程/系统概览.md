## UNIX系统的体系结构
通常来说操作系统也是一种软件，它可以控制计算机硬件，并将硬件的操控能力提供给上层的应用程序，相当于一个中间层。我们通常将这个中间层称之为*内核*
内核暴露给上层的接口称为*系统调用*，内核本身提供的能力比较单一、简洁。为了方便应用程序的开发，会有一些建立在系统调用之上的*公用函数库*来提供支持。
所以应用程序即可调用系统调用，也可以调用公用函数库。
另外还有一种比较特殊的软件 -- shell。它为运行其他应用程序提供了一个接口。shell为用户提供输入命令、执行命令以及作业控制等功能。

## 登录
用户登录UNIX系统时，需要输入用户名和密码。这些信息通常被记录在`/etc/passwd`文件中。
这个文件中的每一行就对应一条完整的用户数据。每条用户数据的字段由冒号分隔。例如：
```shell
用户名:用户密码:用户ID:用户组ID:注释:用户家目录:默认shell
cxl:x:205:105:description:/home/cxl:/bin/zsh
```
这里的用户密码只是一个占位符，实际的密码在`/etc/shadow`(当然也不是明文存储的)
>TODO: 补充密码的文件链接

## 文件和目录
UNIX中所有文件的起点是*根目录（/）*。
目录是一个包含目录项的*文件*。在逻辑上，可以认为每个目录项都包含一个文件名，以及对应的文件属性信息。文件属性信息包含：
1. 文件类型
2. 文件大小
3. 文件所有者
4. 文件权限
5. 文件最后修改的时间
6. 。。。。。。
`stat`和`fstat`两个函数可以获取到文件的属性
> TODO: 补充两个函数的跳转链接

每个进程都有一个*当前工作目录*，所有相对路径都是从这个目录开始的，进程可以用`chdir`函数更改其当前工作目录

## 输入和输出
*文件描述符*是内核用来标识一个特定进程正在访问的文件。通常是一个*最小可用的*非负整数。内核在打开或创建一个文件时会返回这个文件描述符。进程可以用这个文件描述符对文件进行读写操作。
每运行一个新进程，shell都会自动帮其他开3个文件描述符：
1. 标准输入 = STDIN_FILENO = stdin = 0
2. 标准输出 = STDOUT_FILENO = stdout = 1
3. 标准错误 = STDERR_FILENO = stderr = 2
大写字母的定义在`<unistd.h>`文件中，小写字母的定义在`<stdio.h>`文件中
有两大类IO：不带缓冲的IO和标准IO（或者叫带缓冲的IO）。在后面的笔记中会详细记录
> TODO：补充链接

## 程序和进程
> 程序是一个存储在磁盘上某个目录中的可执行文件。内核使用exec函数将程序读入内存，并执行程序。

程序的执行实例称为*进程*。每个进程都有一个进程ID，这个ID总是一个非负整数。
*线程*是进程内的一种抽象，每个线程也有一个线程ID，不过线程ID只在进程内有效。一个进程内的所有线程共享同一地址空间、文件描述符、栈以及与进程相关的属性。因为它们能访问同一存储区，所以在处理多线程时需要保证数据的一致性。

## 出错处理
当UNIX系统函数出错时，通常会返回一个负值，而且整型变量`errno`通常被设置为具有特定信息的值。
有些函数对于出错则使用另一种约定而不是返回负值。例如，大多数返回对象指针的函数，出错时通常返回`NULL`指针
文件`<errno.h>`中定义了`errno`以及可以赋予它的各种常量。
在支持线程的环境中，每个线程都有属于它自己的局部`errno`，以避免一个线程干扰另一个线程对于`errno`要注意两条规则：
- 如果没有出错，其值不会被例程清除。因此仅当函数的返回值明确指出错误时，才检测其值
- 任何函数都不会将`errno`值设置为0，而且在`errno.h`中定义的所有常量都不为0
c标准定义了两个函数，用于打印出错信息
```c
#include <string.h>
// 用于将errnum(通常是errno)映射为一个出错信息字符串，并返回字符串指针
char *strerror(int errnum);
    
#include <stdio.h>
// 给予errno当前值，在标准错误上产生一条出错信息，并返回
void perror(const char *msg);
// 先打印参数msg然后加一个冒号和一个空格，然后是errno对应的错误信息，最后是一个换行符
```
`errno.h`中定义的各种出错分为两类：
- 致命性错误：无法执行恢复动作，最多打印一条出错信息写入日志文件中
- 非致命性错误：有时可以经过妥善的处理让程序恢复运行。大多数非致命性错误都是暂时的 -- 常用的处理方式是延时一会儿再执行

## 用户标识
1. 用户ID不能修改。
2. 如果是root用户，大多数文件权限检测都不再进行
3. 口令文件登录项中也包括用户的组ID，它也是一个数值。这种机制允许同组的各个成员间共享资源
4. 组文件将组名映射为数值的组ID，组文件通常是`/etc/group`
5. 在磁盘上的文件，文件系统都会存储该文件所有者的用户ID和组ID。存储这两个值只需要4个字节
6. 从`4.2BSD`开始就支持了一个用户属于多个组，统称为附属组

## 信号
1. 信号用于通知进程发生了某种情况
2. 进程处理信号的三种方式：
    - 忽略信号：有些信号标识硬件异常，它们会产生不确定的后果，所以不推荐使用这种处理方式
    - 按系统默认方式处理。
    - 捕捉信号：提供一个自编的信号处理函数，对信号进行处理。这样做可以按照我们期望的方式来处理信号
3. 在键盘上有两种方式产生信号，他们都是用于中断当前运行的进程：
    - 中断键`(ctrl + c)`
    - 退出键`(ctrl + \)`
4. 还有一种方式可以产生信号，就是调用`kill`函数。在一个进程中调用此函数可以给另一个进程发送信号，但是这样做是有限制的：*我们必须是接收信号进程的所有者或者超级用户*

## 时间
1. UNIX系统使用两种不同的时间值：
    - 日历时间：`UTC`时间`(从1970年1月1日 00:00:00开始，距今的秒数)`。这种时间用于记录文件最近一次的修改时间等等。系统基本数据类型`time_t`用来保存这种时间值
    - 进程时间：`CPU`时间（用户CPU时间+系统CPU时间）。用来度量进程使用的中央处理器资源。进程时间是以时钟滴答（用`syscon`的`_SC_CLK_TCK`获取）计算。系统基本数据类型`clock_t`用来保存这一时间值
2. 当度量一个进程的执行时间时，Unix系统维护了三个进程时间值:
    - 时钟时间：它是进程运行的时间总量，其值与系统中同时运行的进程数有关。
    - 用户CPU时间：是指执行用户指令所用的时间量
    - 系统CPU时间：是指该进程执行内核程序所经过的时间

## 系统调用和库函数
1. 各个版本的UNIX实现都提供良好定义、数量有限、直接进入内核的入口点，这些入口点被称为系统调用
2. UNIX为每个系统调用在标准C库中设置一个具有相同名字的函数。用户调用该函数，然后该函数又用系统所要求的技术调用相应的内核服务
3. 通用库函数：这些函数与系统函数差不多，它们会调用一个或多个内核的系统调用，但它们并不是内核的入口点。
4. 系统调用一般在`man`手册的*第2部分*
5. 通用库函数一般在`man`手册的*第3部分*
6. 对于实现者的角度来看系统调用和库函数有根本区别，但是从用户的角度来看这两者的区别并不重要。
7. 系统调用和库函数之间的差别：
    - 如果可能的话，我们可以替换库函数，但是我们却无法替换系统调用。
    - 系统调用通常提供一种最小接口，而库函数通常提供比较复杂的功能