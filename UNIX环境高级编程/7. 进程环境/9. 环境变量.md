如同前述，环境字符串的形式是：`name=value`。UNIX内核并不查看这些字符串，它们的解释完全取决于各个应用程序。例如，shell使用大量的环境变量。其中某一些在登录时自动设置（如HOME、USER等），有些则有用户设置。我们通常在一个shell启动文件中设置环境变量以控制shell的动作。例如，若设置了环境变量MALLPATH，则高速`Bourne shell`、`GNU Bourne-again shell`和`Korn shell`到哪里区查看邮件。
ISO C定义了一个函数`getenv`，可以用其取环境变量的值，但是该标准又称环境的内容是由实现定义的。
```c
#include <stdilb.h>
char *getenv(const char *name);
// 返回值：指向与name关联的value的指针；若未找到，返回NULL
```
注意，此函数返回一个指针，它指向name=value字符串中的value。我们应该使用getenv从环境中取一个指定环境变量的值，而不是直接访问`environ`。
Single UNIX Specification中的POSIX.1定义了某些环境变量。如果支持XSI扩展，那么其中也包含了另外一些环境变量定义，下表列出了由Single UNIX Specificationd定义的环境变量，并指明本书讨论的4中实现对它们的支持情况。由POSIX.1定义的各种环境名标记为`·`,否则为XSI扩展。本书讨论的4中UNIX实现使用很多依赖于实现的环境变量。注意，ISO C没有定义任何环境变量。
![[Pasted image 20250528174026.png]]
除了获取环境变量值，有时也需要设置环境变量。我们可能希望改变现有环境变量的值，或者是增加新的环境变量。（在下一章将会了解到，我们能影响的只是当前进程及其后生成和调用的任何子进程的环境，但不影响父进程的环境，这通常是一个shell进程。尽管如此，修改环境表的能力依然是很有用的。）遗憾的是，并不是所有系统都支持这种能力。下图列出了由不同的标准及实现支持的各种函数。
![[Pasted image 20250528174238.png]]
下面是中间3个函数的原型
```c
#include <stdlib.h>
int putenv(char *str);
// 函数返回值：若成功，返回0；若出错，返回非0

int setenv(const char *name, const char *value, int rewrite);
int unsetenv(const char *name);
// 两个函数返回值：若成功，返回0；若出错，返回-1
```
这三个函数的操作如下：
* putenv取形式为`name=value`的字符串，将其放到环境表中。如果name已经存在，则先删除其原来的定义。
* setenv将name设置为value。如果环境中name已经存在，那么（a）若rewrite非0，则首先删除其现有定义；（b）若rewrite为0，则不删除其现有定义（name不设置为新的value，而且也不出错）。
* unsetenv删除name的定义。即使不存在这种定义也不算出错。

> 注意，putenv和setenv之间的差别。setenv必须分配存储空间，以便依据其参数创建name=value字符串。putenv可以自由的将传递给它的参数字符串直接放到环境中。确实，许多实现就是这么做的，因此，将存放在栈中的字符串作为参数传递给putenv就会发生错误，其原因是，从当前函数返回时，其栈帧占用的存储区可能将被重用。

这些函数在修改环境表时是如何进行操作的呢？对这一问题的进行研究、考察是非常有益的。回忆7.6节中的程序存储区分布图，其中，环境表（指向实际name=value字符串的指针数组）和环境字符串通常是放在进程存储空间的顶部（栈之上）。删除一个字符串很简单——只要先在环境表中找到该指针，然后将所有后续指针向环境表首部顺次移动一个位置。但是增加一个字符串或修改一个现有的字符串就困难得多。环境表和环境字符串通常占用的是进程地址空间的顶部，所以它不能在向高地址方向（向上）扩展：同时也不能移动在它之下的各栈帧，所以它也不能向低地址（向下）扩展。两者则和使得该空间的长度不能在增加。
（1）如果修改一等现有的name：
	a. 如果新value的长度少于或等于现有value的长度，则只要将新字符串复制到原字符串所用的空间中；
	b. 如果新value的长度大于原长度，则必须调用malloc为新字符串分配空间，然后将新字符串复制到该空间中，接着是环境表中针对name的指针指向新分配区。
（2）如果要增加一个新的name，则操作就更加复杂。首先，必须调用malloc为name=value字符串分配空间，然后将该字符串复制到空间中。
	a. 如果这是第一次增加一个新name，增必须调用malloc为新的指针表分配空间。接着，将原来的环境表复制到新分配区，并将指向新name=value字符串的指针存放在该指针表的表尾，然后又将一个控制真存放在其后。最后使environ指向新指针表。再看一下7.6节中的图，如果原来的环境表位于栈顶之上（这是一种常见情况），那么必须将此表移至堆中。但是，此表中的大多数指针仍指向栈顶之上的各name=value字符串。
	b. 如果这不是第一次增加新name，则可知以前已调用malloc在堆中为环境表分配了空间，所以只需要调用realloc，以分配比元空间多存放一个指针的空间。然后将指向新name=value字符串的指针存放在该表表尾，后面跟这一个空指针。